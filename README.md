# Problems from test to Student Camp from Yandex and MIPT
---
# Задача: 01_Сумма квадратов

**Условие задачи:**

Дано натуральное число \( n \). Определить, можно ли его представить в виде суммы квадратов двух целых чисел.  
Если можно, выведите \( a \) и \( b \), где \( a^2 + b^2 = n \). Если нельзя - выведите "NO". Если \( a \) и \( b \) для данного \( n \) несколько, выведите такую пару, в которой \( a \) минимальное.  
Используйте функцию, которая возвращает указатели на целочисленный тип и принимает указатели как параметры.

**Формат ввода:**
- На вход подается натуральное число \( n \).

**Формат вывода:**
- Если число \( n \) можно представить в виде суммы квадратов двух целых чисел, выведите два числа \( a \) и \( b \),
  <br>таких что \( a^2 + b^2 = n \). Если таких пар несколько, выведите пару с минимальным \( a \).
- Если число \( n \) нельзя представить в виде суммы квадратов двух целых чисел, выведите "NO".

**Примечание:**
- Гарантируется, что \( n \) — натуральное число.

  *Результат 5/5 баллов.*

# Задача: 02_Зависимости

**Условие задачи**

При установке какого-либо пакета в операционной системе Linux необходимо учитывать сложную взаимосвязь пакетов между собой. Если пакет А зависит от пакета Б, а тот — от пакета В, то сначала следует установить В, потом Б и лишь потом — А. Таким образом при запросе на установку необходимо сформировать список пакетов и расположить их в том порядке, в котором их можно устанавливать. Если попробовать сначала установить пакет Б, а лишь потом В — возникнет ошибка. К счастью, мы можем посмотреть на зависимости конкретного пакета, выполнив следующую команду: 
```
$ debtree --no-alternatives --no-recommends --no-provides --no-conflicts cpp-10 > cpp-10.dot
```
Данная команда создаст файл cpp-10.dot, в котором будет вся необходимая нам информация. Для пакета cpp-10 данный файл выглядит следующим образом:

```
digraph "cpp-10" {
    rankdir=LR;
    node [shape=box];
    "cpp-10" -> "gcc-10-base" [color=blue,label="(= 10.5.0-1ubuntu1~22.04)"];
    "cpp-10" -> "libgmp10" [color=blue,label="(>= 2:6.2.1+dfsg)"];
    "cpp-10" -> "libisl23" [color=blue,label="(>= 0.15)"];
    "libisl23" -> "libgmp10" [color=blue,label="(>= 2:6.2.1+dfsg)"];
    "cpp-10" -> "libmpc3" [color=blue,label="(>= 1.1.0)"];
    "libmpc3" -> "libgmp10" [color=blue,label="(>= 2:6.2.1+dfsg)"];
    "libmpc3" -> "libmpfr6" [color=blue,label="(>= 4.0.0)"];
    "libmpfr6" -> "libgmp10" [color=blue,label="(>= 2:6.2.1+dfsg)"];
    "cpp-10" -> "libmpfr6" [color=blue,label="(>= 3.1.3)"];
    "cpp-10" -> "libzstd1" [color=blue,label="(>= 1.4.0)"];
    "cpp-10" -> "gcc-10-locales" [style=dotted,label="(>= 10)"];
    "cpp-10" [style="setlinewidth(2)"]
    "gcc-10-locales" [shape=diamond];
}
// Excluded dependencies:
// libc6 zlib1g
// total size of all shown packages: 46455808
// download size of all shown packages: 14076678
```
Здесь нам интересны строки, в которых присутствует подстрока ”->”, обозначающая зависимость одного пакета от другого. Например, cpp-10, напрямую зависит от libisl23, а libisl23 - от libgmp10 и т.д.

Вам предлагается собрать информацию о зависимостях между пакетами из подобного и вывести их названия в том порядке, в котором их можно устанавливать.

Кстати, вы можете сохранить диаграмму в PNG формате и посмотреть на граф зависимостей выполнив команду:

```
$ dot -T png -o cpp-10.png cpp-10.dot
```
Для пакета cpp-10 граф зависимостей выглядит следующим образом:

![граф зависимостей](https://contest.yandex.ru/testsys/statement-file?hash=eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0..GrDJQuChz8tYSXDl.W6QzbWcRRPS0CsvndzxvPX4ZYKBU-M52_Vqbu6xBdfMAeyJ2PO-8g9Ah0zLTSTKO2NYVcaIbDfjn2ShxOMqzVO87YnKa-VY9zyh_EusmCW8.IMORsymyQMaIFtLX46M6dg)

**Формат ввода:**
В качестве входного файла используется результат выполнения следующей команды для одного из пакетов:

```
$ debtree --no-alternatives --no-recommends --no-provides --no-conflicts <package-name>
```
В списке отсутствуют альтернативные пакеты, дополнительные рекомендации и циклические зависимости. Обратите внимание, что в начале строк, которые описывают зависимости утилита debtree ставит символ табуляции.

**Формат вывода:**
Список имен пакетов, в том порядке, в котором их можно устанавливать. Каждое имя на новой строке.

**Ввод:**
```
digraph "adduser" {
	rankdir=LR;
	node [shape=box];
	"adduser" -> "passwd" [color=blue];
	"adduser" -> "debconf" [color=blue,label="(>= 0.5)"];
	"adduser" [style="setlinewidth(2)"]
	"debconf" [shape=diamond];
	"passwd" [shape=diamond];
}
// total size of all shown packages: 622592
// download size of all shown packages: 155528
```

**Вывод:**
```
debconf
passwd
adduser
```

*Результат 25/25 баллов.*

# Задача: 03_Декоратор_проверки_аргументов

**Условие задачи:**

Напишите декоратор @takes, который будет проверять правильность типов входных аргументов функции.

Декоратор принимает на вход типы аргументов и декорирует функцию таким образом, что она генеририрует исключение TypeError, если хотя бы один из аргументов имеет неверный тип.
Если аргументов больше, чем типов, то ошибку генерировать не нужно (возможно, точный тип известен только для первых аргументов, его, как раз, надо проверить).
Если типов больше, чем аргументов, то это тоже ошибка только в случае, если переданные аргументы не подходят под соответствующие им по порядку типы. (декоратор может быть применен к функциям с переменным числом аргументов).

Декоратор должен вести себя порядочно, то есть не должен затирать основные аргументы функции (__name__, __doc__, __module__).

Для простоты можно считать, что у функции нет именованных аргументов.

Генерацию исключений воспринимайте пока как волшебный способ просигнализировать об ошибке. Делается это так: 
```
raise TypeError
```

**Формат ввода:**
Ваш код должен иметь такой вид:

```
import sys

...

```
ваши импорты и реализация

декоратор должен называться "takes"

```
...

exec(sys.stdin.read())

```
(Программа выполнит код, записанный во входном файле)

**Ввод:**
```
# this is for similar behaviour in python 2 and python 3
from __future__ import print_function


@takes(int, str)
def f(a, b):
    print(a, b)

try:
    f(1, 'abcd')
except Exception as e:
    print(type(e).__name__)
```
**Вывод:**
```


1 abcd
```

*Результат 20/20 баллов.*

# Задача: 04_Питание_студента

**Условие:**
Стипендия Леши составляет n рублей. Одна шаурма в палатке рядом с общежитием Леши стоит a рублей, а один комплексный обед в столовой стоит b рублей. Он может купить любое целое неотрицательное количество шаурмы и любое целое неотрицательное количество обедов в столовой.

Определите, сможет ли Леша купить несколько шаурмы и комплексных обедов так, чтобы потратить ровно всю стипендию без остатка.

Иными словами, вам необходимо найти два неотрицательных целых числа x и y таких, что Леша может купить x порций шаурмы, y комплексных обедов, при этом:

x * a + y * b = n

Либо сообщить, что такие числа найти невозможно.

**Формат ввода:**

<br>В первой строке записано целое число n (1 &le; n  &le; 10000000) — стипендия Леши.
<br>В первой строке записано целое число n (1 &le; n  &le; 10000000) — стоимость одной шаурмы.
<br>В первой строке записано целое число n (1 &le; n  &le; 10000000) — стоимость одного комплексного обеда.

**Формат вывода:**

Если Леша не сможет купить шаурму и комплексные обеды так, чтобы потратить ровно n рублей, выведите «NO» (без кавычек).
В противном случае, в первую строку выведите «YES» (без кавычек). 
<br>Во вторую строку выведите два целых неотрицательных числа x и y  — количество шаурм и количество комплексных обедов, 
<br>которые должен купить Леша, чтобы потратить ровно n рублей, то есть x * a + y * b = n. Если ответов несколько выберите вариант с минимальным x. Любое из чисел x, y может быть равно 0.

*Результат 10/10 баллов.*

# Задача: 05_Максимум_последовательности

**Условие задачи:**

При каком натуральном n выражение (1000^n) / (n!) принимает максимальное значение?

Ответ: 999

*Результат 7/7 баллов.*

# Задача: G1ML

**Условие задачи:**

*Оценка в этой задаче будет дробной, от 0 до 15 балла.*

На большом космическом корабле для оценки состояния внешней обшивки в 1200 точках установлены датчики. В каждой из точек датчики меряют 6 анонимных инженерных параметров, пронумерованных латинскими буквами от
A до F, а также температуру в градусах Кельвина. В результате прохождения через электромагнитную аномалию часть температурных датчиков вышло из строя. К счастью, датчики, измеряющие анонимные параметры оказались исправны. Инженеры корабля считают, что анонимные признаки можно использовать, чтобы оценить температуру. Ваша задача -- построить эту оценку, то есть предсказать температуру в точках, где датчики вышли из строя.

**О датасете:**
Вам предлагаются три файла, train.csv, test.csv и example.csv:
- Файл `train.csv` содержит 6 анонимных признаков и колонку `target` с измерениями
   температуры в градусах Кельвина для обучающей выборки из 800 точек с исправными датчиками.
- Файл `test.csv` содержит измерения в 400 точках, в которых известны только анонимные параметры.
- Файл `example.csv` содержит пример корректной посылки в контест.
Таким образом, вам нужно предсказать колонку target для спутников из файла test.csv.

**Что нужно сделать:**
От вас требуется загрузить в систему файл answers.csv в формате, аналогичном файлу example.csv с предсказаниями температуры для спутников из тестовой выборки. В качестве целевой метрики используется корень из среднеквадратичной ошибки (RMSE).

Баллы за это задание рассчитываются по формуле:

*15 * max(min((50 - RMSE) / 40, 1), 0)*,

где RMSE - значение ошибки для ваших предсказаний.

Таким образом, для максимального числа баллов необходимо набрать RMSE &le; 10.

*Результат 7.13/15 баллов.*

# Задача: H1ML

**Условие задачи:**
Астрофизики обнаружили планету с неравномерным гравитационным полем. Чтобы изучить этот феномен было принято решение отправить на поверхность планеты роботизированное оборудование. Для этого требуется составить гравитационную карту участка, на которую возможно приземление: между 55-60 градусами восточной долготы и 34-37 градусами северной широты. С орбиты удалось измерять интенсивность гравитационного поля только в 300 точках, а восстановить по ним приблизительную карту всего участка предстоит Вам.

**О датасете:**
Вам предлагаются два файла, field_train.csv и field_example.csv. Файл field_train.csv содержит информацию о проведенных с орбиты измерениях гравитационного поля. Он содержит следующие три столбца:

- latitude: долгота точки (в градусах), в которой производилось измерение
- longitude: широта точки (в градусах), в которой производилось измерение
- intensity: интенсивность гравитационного поля в данной точке (в условных единицах)

Шаг координатной сетки составляет 0.1 градуса. Файл field_example.csv организован аналогичным образом и содержит валидные предсказания для всех остальных точек, в которых замеры не приводились. Столбец intensity сгенерирован случайным образом, вам предлагается использовать этот файл в качестве шаблона.

**Что нужно сделать:**

От вас требуется загрузить в систему файл answers.csv в формате, аналогичном field_example.csv с предсказаниями интенсивности гравитационного поля. В качестве целевой метрики используется коэффициент детерминации R^2.
Баллы за это задание рассчитываются по формуле:

*15 * max(min((R^2 - 0.19) / 0.8, 1), 0)*,

где R^2  - значение коэффициента детерминации ваших предсказаний. Таким образом, для максимального числа баллов необходимо набрать R^2 &le; 0.99










